module lambda

alias MapCallback = fn(v: a): v

enum bool(true | false) =
  fn op_eq(x: bool, y: bool) = x == y
  fn op_ne(x: bool, y: bool) = x != y
  fn op_and(x: bool, y: bool) = x && y
  fn op_or(x: bool, y: bool) = x || y
  fn op_xor(x: bool, y: bool) = x <> y
  fn op_not(x: bool,): bool = !x
  fn str(x: bool) = x ? "true" : "false"


enum List<a>(First | Link(v: a, rest: List)) =
  fn each(self, cb: fn(v: a)) =
    match self
      List::First -> List::First
      List::link(v, rest) ->
        cb(v)
        each(rest, cb)

  fn map(self, cb: fn(v: a): v) =
    match self
      First -> First
      Link(v, rest) -> List::Link(cb(v), map(rest, cb))

enum Temperature(Celsius(float) | Fahrenheit(float)) =
  fn str(self) =
    match self
      Temperature::Celsius(t) && t > 30 -> "${t}C is above 30 Celsius"
      Temperature::Celsius(t) -> "${t}C is below 30 Celsius"
      Temperature::Fahrenheit(t) && t > 86 -> "${t}F is above 86 Fahrenheit"
      Temperature::Fahrenheit(t) -> "${t}F is below 86 Fahrenheit"

struct Cat(name: str, age: int) =
  fn fullname() =
    name + age.str()

  fn talk() =
    println("cat ${name} says meow")

  test "Cat" =
    c = Cat(name = "123", age = 1)
    c.talk()
    Cat("rabby", 21).fullname() == "rabby21"

fn fib(n: int): int =
  match n
    0 | 1 -> n
    else -> fib(n - 1) + fib(n - 2)

fn factorial(n: int): int =
  match n
    1 -> 1
    _ -> n * factorial(n - 1)

fn to-celsius(f: float) =
  (f - 32) * (5 / 9)

fn repeat(n: int, cb: fn(int)) =
  if n != 0:
    cb(n)
    repeat(n-1, cb)

fn range(start: int, e: int, cb: fn(int)) =
  if (start < end):
    cb(start)
    range(start + 1, end, cb)
  elif (start > end):
    cb(start)
    range(start - 1, end, cb)

fn main() =
  repeat(10) |i|
    println(i)
  range(10, 20) |i|
    println(i)

/// Http similar to rocket
/// GET,DELETE Request -> fn params are got from query
/// POST,PUT,PATCH Request -> fn params got from multi part form body
/// DI at compiler level
/// Controller similar to IHP

#[path("/counters")]
@path("/counters")
struct CounterController(db: DB)
  static path = "/counters"

  fn all(): HttpResponse =
    counters := db.query(Counter).fetchAll()
    render(CounterList(counters))

  fn view() =
    counter := fetchOne(Counter) ?? createOne(Counter)
    if counter := fetchOne(Counter)
      render CounterView(counter)
    else
      counter <- newRecord @Counter |> set #count 0 |> createRecord
      render CounterView(counter)

  fn increment(id: str) =
    counter <- fetch counterId
    updatedCounter <- counter |> incrementField #count |> updateRecord
    respondHtml $ counterView updatedCounter

  fn decrement(id: str) =
    counter <- fetch counterId
    updatedCounter <- counter |> decrementField #count |> updateRecord
    respondHtml $ counterView updatedCounter