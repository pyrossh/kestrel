data.price?.take_if(|a| a != "")
trait Iterator(
  fun has_next(): Bool
  fun next(): T?
)

trait HasEq[A](
  fn eq(that: a): bool
)

trait Equatable[A]
  `A trait that defines equal and not equal operations

  fn eq(b: Equatable[A]): bool
  fn ne(b: Equatable[A]): bool
end

enum Compare
  | Less
  | Equal
  | Greater
end

trait Comparable[A] is Equatable[A]
  fn lt(that: A): bool
  fn le(that: A): bool 
  fn ge(that: A): bool
  fn gt(that: A): bool
  fn compare(that: a): Compare
end

enum list<T> =
  | empty
  | link(v: T, rest: list<T>)

fn list.of[A](values: ...A): list[A] =
  list[A]().add(values)

fn (o list<T>) each(cb: fn(v: T)) =
  match o
    empty -> return
    link(a, rest) ->
      cb(a)
      rest.each(cb)

fn (l: list) append(values: ...V) =
  `adds the specified elements to the start of the list
  range(values) |v|
    l.add(v)

fn (l: list) append(v: V) =
  `adds the specified elements to the start of the list
  l.last().rest = link(v, empty)

fn (l: list) prepend(v: V) =
  `adds the specified elements to the start of the list
  l.first() = link(v, l.first())


fn range(start: int, e: int, cb: fn(int)) =
  match start < end ->
    cb(start)
    range(start + 1, end, cb)

fn repeat(n: int, cb: fn(int): void) =
  match n != 0
    cb()
    repeat(n - 1, cb)

fn repeat(cb: fn(int): void) =
  cb()
  repeat(cb)

fn iterate[T](l: list[T], cb: fn(t: T)) =
  pass

fn main() =
  repeat(10) |i|
    println(i)
  range(10, 20) |i|
    println(i)

```
fn create_post_action(req: Request): Result[Response] =
  post := Post(title = req.params.title, body = req.params.body)
  if post.valid()
    RenderNewView()
  else
    post := createRecord(post)
    setSuccessMessage("Post created")
    redirectTo("/posts")

fn divide(dividend: u32, divisor: u32) !u32 =
  if divisor == 0
    error.DivideByZero
  else
    dividend / divisor

error FileOpenError
  | AccessDenied(str)
  | OutOfMemory(str)
  | FileNotFound(str)

fn parse_version(header: List[int]): result[Version, error] =
  header.get(0) != nil ? v : error.InvalidHeaderLength(header.get(0))

fn main(): result[unit, unit] =
  version := parse_version(list.of(1, 2))
  match pg.connect()
    ok(c) -> return 0
    err(e) -> return e

  greeting_file := file.open("hello.txt").unwrap_or_else() |error|
    match error
      ErrorKind::NotFound ->
        File::create("hello.txt").unwrap_or_else() |error|
          panic!("Problem creating the file: {:?}", error)
      _ ->
        panic!("Problem opening the file: {:?}", error)

  conn := match pg.connect()?
  create_post_action(req)
    .map(|v| 0)
    .map_err(|err| 1)

  create_post_action(req)?
  ok()

  greeting_file := file.open("hello.txt")?
  ok()

import std/str
import std/result

fn double_number(s: str): result[i32, unit] =
  number_str.parse_int().map(|n| 2 * n)

fn main(): result<i32, unit> =
  double_number("10")


use std::num::ParseIntError;

fn double_number(number_str: &str) -> Result<i32, ParseIntError> {
    number_str.parse::<i32>().map(|n| 2 * n)
}

fn main() {
    match double_number("10") {
        Ok(n) => assert_eq!(n, 20),
        Err(err) => printLn!("Error: {:?}", err),
    }
}

trait error: debug + display (
  fn description(): str
  fn cause(): option<error>
)

trait From<T>(
  fn from(v: T) -> Self;
)

trait Debug(
  fn fmt(f: Formateer): result[unit, unit]
)

trait Display(
  fn fmt(f: Formateer): result[unit, unit]
)

record Car(wheels: int)

fn getWheels() =
  returns 4

fn main() =
  let c1 = some(Car(wheels: 2))
  let c2: option<Car> = none

  let c1 = Some(Car(wheels: 2))
  let c2: Option<Car> = None

  match c
    none -> print("no car")
    some(car) -> car.getWheels()

  Car c2 = null
  c2.getWheels() // Null pointer
```

(1 + 2).mod(3).pow(2).sqrt()

math.sqrt(math.pow(math.mod(1 + 2, 3)))

repeat(10) |i|
  pass

repeat(n) |i|
  pass

data.each() |k, v|
  pass

list.of(1, 2, 3).each() |v, i|
  pass

map.of("a" => 1, "b" => 2).each() |k, v|
  pass

repeat() |_|
  pass

repeat(|_| i < 9) |i|
  pass

repeat(|_| a > b && c < d) |i|
  pass